//와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다.
//와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다.
//
//
//와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자.
//단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다.
//
//
//예를 들어 와일드 카드 he ? p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다.
//와일드 카드* p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다.
//
//
//와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.
//
//
//입력
//입력의 첫 줄에는 테스트 케이스의 수 C(1 <= C <= 10) 가 주어진다.
//각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N(1 <= N <= 50) 이 주어진다.
//그 후 N 줄에 하나씩 각 파일명이 주어진다.
//파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에* 와 ? 를 가질 수 있다.
//모든 문자열의 길이는 1 이상 100 이하이다.
//
//
//출력
//각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.
//
//https://www.algospot.com/judge/problem/read/WILDCARD
//#define test
#define FOR(i,n) for(int i=0;i<n;i++)

#include <iostream>
#include <sstream>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <memory>

using namespace std;

namespace WILDCARD {
    bool WildCompare(const string& a, const string& b) {
        if (a.size() != b.size())
            return false;
        FOR(i, a.size())
            if (!(a[i] == b[i] || a[i] == '?' || b[i] == '?'))
                return false;
        return true;
    }
    vector<string> FilterByWildcard(const string& wildcard, const vector<string>& files) {
        string prefix, suffix, buffer;
        bool prefixFlag = true;
        vector<string> substrings;
        stringstream wildcardStream(wildcard);
        while (getline(wildcardStream, buffer, '*'))
        {
            if (buffer.empty()) {
                prefixFlag = false;
                continue;
            }
            if (prefixFlag)
            {
                prefixFlag = false;
                prefix = buffer;
            }
            else
                substrings.push_back(buffer);
        }
        if (wildcard[wildcard.size() - 1] != '*')
        {
            suffix = buffer;
            if (!substrings.empty())
                substrings.erase(substrings.begin() + substrings.size() - 1);
        }
        vector<string> res;
        FOR(i, files.size()) {
            if (!WildCompare(prefix, files[i].substr(0, prefix.size())))
                continue;
            if (!WildCompare(suffix, files[i].substr(files[i].size() - suffix.size())))
                continue;
            auto substring = substrings.begin();
            for (int j = 0; j < files[i].size() && substring != substrings.end(); j++)
                if (WildCompare(*substring, files[i].substr(j, substring->size())))
                    substring++;
            if (substring == substrings.end())
                res.push_back(files[i]);
        }
        return res;
    }
    void WILDCARD();
    //#ifndef MainFile
    void WILDCARD() {
#ifdef test
        stringstream cin(string("2\nhe?p\n3\nhelp\nheap\nhelpp\n*p*\n3\nhelp\npapa\nhello\n"));
#endif
        int C;
        cin >> C;
        FOR(i, C) {
            string wildcard;
            int N;
            cin >> wildcard;
            cin >> N;
            vector<string> files(N);
            FOR(i, N)
                cin >> files[i];
            auto res = FilterByWildcard(wildcard, files);
            sort(res.begin(), res.end());
            for (auto each : res)
                cout << each << endl;
        }
    }
    //#endif
}
#ifndef YunuComputer
int main() {
    WILDCARD::WILDCARD();
}
#endif

